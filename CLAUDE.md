# CLAUDE.md for mcp-jujutsu

このファイルは Claude Code (claude.ai/code) がこのリポジトリのコードを理解し、作業するための指針を提供します。

## リポジトリ概要

MCP-Jujutsu は、Jujutsuバージョン管理システムを利用してセマンティックコミット分割を行うModel Context Protocol (MCP)サーバーを実装しています。大きなコミットを分析し、より意味のある小さなセマンティック単位に分割して、release-please形式に準拠した適切なコミットメッセージを付与します。

## プロジェクト構造

### 主要ディレクトリ
- `src/` - ソースコード
  - `core/` - 共通コアコンポーネント
  - `single_repo/` - 単一リポジトリモード
  - `multi_repo/` - マルチリポジトリモード
  - `client/` - クライアント実装
- `tests/` - テストファイル
- `docs/` - ドキュメント
- `build/` - ビルド成果物（Gitで追跡しない）
- `scripts/` - スクリプト
- `card/` - MCPカード定義
- `examples/` - 使用例
- `vendor/` - 外部依存関係

### 主要ファイル
- `mcp_jujutsu.nimble` - パッケージ定義
- `TODO.md` - 現在のタスクと将来の計画
- `CLAUDE.md` - このファイル

## ビルド＆開発コマンド

```bash
# プロジェクトのビルド
nimble build

# テストの実行
nimble test

# ドキュメントの生成
nimble docs

# リリースバージョンのビルド
nimble release

# デバッグバージョンのビルド
nimble debug
```

## Jujutsuワークスペースの操作

このプロジェクトはJujutsuワークスペースを使用して並行開発を行います：

```bash
# ワークスペース一覧
jj workspace list

# 新しいワークスペースを追加
jj workspace add <パス>

# 古くなったワークスペースを更新
jj workspace update-stale

# ワークスペースを忘れる
jj workspace forget <パス>
```

重要なワークスペースの概念：
- 各ワークスペースは独立した作業コピーを持ちます
- すべてのワークスペースは同じリポジトリを共有します
- 一つのワークスペースでの変更により、他のワークスペースが古くなる可能性があります
- 古くなったワークスペースを更新するには `jj workspace update-stale` を使用します

## コア概念

### MCPプロトコル

MCP（Model Context Protocol）はAIモデルと外部ツール/データソース間の通信を標準化するために使用されます。このプロトコルはメッセージ交換にJSON-RPC 2.0を使用し、以下を定義します：

- **トランスポート**: 通信メカニズム（HTTP、stdio）
- **リソース**: モデルがアクセスするデータソース
- **ツール**: モデルが呼び出せる関数
- **プロンプト**: 構造化されたメッセージテンプレート

### セマンティックコミット分割

コア機能は大きな混合コミットを、より小さなセマンティック的に一貫性のある単位に分割します：

1. **分析**: コミットの差分を調べて論理的な境界を特定
2. **グループ化**: 関連する変更をセマンティック単位にグループ化
3. **メッセージング**: release-please形式に沿った適切なコミットメッセージを生成
4. **実行**: 分割された変更で新しいコミットを作成

### Jujutsu統合

Jujutsuは、Gitと互換性のあるバージョン管理システムで、拡張機能を備えています：

- 非線形履歴の可視化をサポート
- 操作ベースのマージに焦点
- パワフルなコミット選択のためのレブセット
- 柔軟な履歴書き換え

サーバーはJujutsuと連携して以下を行います：
- コミットの差分を取得
- 新しいコミットを作成
- ブランチと履歴を管理

## コード規約

1. **命名**:
   - 変数と関数にはcamelCaseを使用
   - 型にはPascalCaseを使用
   - ファイル名にはsnake_caseを使用

2. **ドキュメント**:
   - すべての公開プロシージャと型を文書化
   - docstringに例を含める
   - Nimドキュメントガイドラインに従う

3. **テスト**:
   - すべての機能に単体テストを書く
   - unittestモジュールを使用
   - テスト命名規則に従う: `test_*.nim`

4. **エラー処理**:
   - Nimの例外システムを使用
   - 詳細なエラーメッセージを提供
   - リソースの適切なクリーンアップを確保

## 一般的なワークフロー

1. **新しいツールの追加**:
   - `mcp/tools/`に新しいプロシージャを作成
   - サーバー初期化でツールを登録
   - 適切なテストを追加

2. **分析の拡張**:
   - `analyzer/`でセマンティック分析を修正
   - 新しいパターン認識ロジックを追加
   - テストを更新

3. **トランスポートの追加**:
   - `mcp/transport/`に新しいトランスポートを作成
   - 必要なインターフェースを実装
   - サーバー設定で登録

## テストガイドライン

1. すべての公開APIには対応するテストが必要
2. コミット前に `nimble test` を実行
3. 可能な場合は外部依存関係をモック化
4. 非同期機能には非同期テストを使用

## コミットメッセージ形式

このプロジェクトはrelease-pleaseコミット形式に従います：

```
<type>[optional scope]: <description>
```

タイプには以下が含まれます：
- `feat:` - 新機能（マイナーバージョン）
- `fix:` - バグ修正（パッチバージョン）
- `docs:` - ドキュメントの変更
- `style:` - フォーマットの変更
- `refactor:` - バグを修正したり機能を追加したりしないコード変更
- `perf:` - パフォーマンスの改善
- `test:` - テストの追加または更新
- `chore:` - メンテナンスタスク

破壊的変更はタイプの後に `!` をつけるか、フッターで示します：
```
feat!: 破壊的変更を伴う新機能を追加
```
または
```
feat: 新機能を追加

BREAKING CHANGE: これはAPIを変更します
```